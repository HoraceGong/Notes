# Java三大特性

## 封装

利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问这个对象。

优点:

- **减少耦合**: 可以独立地开发、测试、优化、使用、理解和修改
- **减轻维护的负担**: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块
- **有效地调节性能**: 可以通过剖析确定哪些模块影响了系统的性能
- **提高软件的可重用性**
- **降低了构建大型系统的风险**: 即使整个系统不可用，但是这些独立的模块却有可能是可用的

## 继承

不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。**通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。**

**关于继承如下 3 点请记住：**

1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。

## 多态

多态分为编译时多态和运行时多态:

- 编译时多态主要指方法的重载
- 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定

运行时多态有三个条件:

- 继承
- 覆盖(重写)
- 向上转型

# Java参数传递

## 形参&实参

方法的定义可能会用到**参数**，参数在程序语言中分为：

- **形参(Parameters)**：用于定义函数/方法，接收实参，不需要有确定的值
- **实参(Arguments)**：用于传递给函数/方法的参数，必须有确定的值

## 值传递&引用传递

程序设计语言将实参传递给方法（或函数）的方式分为两种：

- **值传递**：方法接收的是实参值的拷贝，会创建副本。
- **引用传递**：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。

## Java中只存在值传递



# Java String

String被声明为final，因此它不可被继承。

内部使用char数组存储数据，且**该数组被声明为`final`**，这意味着value数组初始化之后就不能再引用其他数组。并且**String内部没有改变value数组的方法**，因此可以保证String不可变。

## 不可变的好处

- **可以缓存hash值**：因为String的hash值经常被使用（比如String用作HashMap的key）。不可变的特性可以使得hash值也不会变，因此只需要进行一次计算。
- **String Pool的需要**：如果一个String对象已经被创建过了，那么就会从String Pool中取得引用。只有String是不可变的，才可能使用String Pool。
- **安全性**：String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。
- **线程安全**：String不可变性天生具备线程安全特性，可以在多个线程中安全地使用。

## String, StringBufffer, StringBuilder

1. 可变性

- String不可变
- StringBuffer, StringBuilder可变

2. 线程安全

- String不可变，因此是线程安全的
- StringBuilder不是线程安全的
- StringBuffer是线程安全的，内部使用`synchronized`进行同步

## String.intern()

使用`String.intern()`可以保证相同内容的字符串变量引用同一的内存对象。

下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。intern() 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。

```java
String s1 = new String("aaa");
String s2 = new String("aaa");
System.out.println(s1 == s2);           // false
String s3 = s1.intern();
System.out.println(s1.intern() == s3);  // true
```

如果是采用`"bbb"`这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入String Pool中。

```java
String s4 = "bbb";
String s5 = "bbb";
System.out.println(s4 == s5); //true
```

