---
title: MySQL强化笔记
date: 2024-05-26 20:08:14
tags: [MySQL, note]
---

包括MySQL基础、MySQL调优等。

<!-- more -->

# 存储引擎

## MySQL四层架构

1. 连接层

   最上层是一些**客户端和链接服务**，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为**通过认证安全接入的客户端提供线程**。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。

2. 服务层

   第二层架构主要完成大多数的**核心服务功能**，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。

3. 引擎层

   存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取。**数据库中的索引是在存储引擎层实现的**。

4. 存储层

   数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。

## 什么是存储引擎

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。**存储引擎是基于表的**，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。



三种常见的存储引擎：

- InnoDB：兼顾高可靠性和高性能的通用存储引擎，在MySQL 5.5之后，是**默认的存储引擎**。
- MyISAM：MySQL早起的默认存储引擎
- Memory：表数据临时存储在内存中，由于受到硬件问题或断电问题等的影响，只能将这些表作为临时表或者缓存使用



### InnoDB

- DML操作遵循ACID模型，支持事务
- 行级锁，提高并发访问性能
- 支持外键约束，保证数据的完整性和正确性

文件：

xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和**索引**。文件是**基于二进制的**。MySQL提供指令`ibd2sdi`，可以通过该指令从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。

### MyISAM

- 不支持事务，不支持外键
- 支持表锁，不支持行锁
- 访问速度快

文件：

- xxx.sdi：存储表结构信息

- xxx.MYD: 存储数据

- xxx.MYI: 存储索引

### Memory

- 内存存放
- hash索引（默认）

## 存储引擎如何选择

- InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用**对事务的完整性有比较高的要求**，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还**包含很多的更新、删除操作**，那么InnoDB存储引擎是比较合适的选择。
- MyISAM ：如果应用是**以读操作和插入操作为主**，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。
- MEMORY：将所有数据保存在内存中，**访问速度快**，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。

## （待补充）InnoDB的逻辑存储结构



# 索引

索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

## 索引结构

| 索引结构              | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| B+树索引              | 最常见的索引类型，大部分引擎都支持B+树索引                   |
| Hash索引              | 底层数据结构是使用**哈希表**实现的，**只有精确匹配索引列的查询才有效**，不支持范围查询 |
| R-tree（空间索引）    | MyISAM的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
| Full-text（全文索引） | 是一种通过建立倒排索引，快速匹配文档的方式                   |

### 索引结构为什么会选择B+树

B+树与B树相比，有以下三点区别：

- 所有数据都会出现在叶子结点
- 叶子结点形成一个单向链表
- 非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的

MySQL在原B+树的基础上，增加了一个指向相邻叶子结点的链表指针，就形成了带有顺序指针的B+树，提高区间访问的性能，便于排序。

**选择B+树的原因：**

- 更适合范围查询：若使用B树，因为数据存储在不同层的节点上，范围查询时需要跨多层回溯。而B+树所有数据都仅在叶子结点上，且叶子结点通过双向链表连接，范围查询只需要遍历链表即可。
- 更高的存储利用率：B树每个结点都要存储数据，导致单个节点可以容纳的键数量较小。而B+树仅存储键，单个节点能容纳更多键，树的高度更低，磁盘IO次数也就更少。
- 更稳定的查询性能：B+树所有数据均存储在叶节点上，每次查询必须走到叶子结点，路径长度一致，性能稳定。
- 更高效的全表扫描：B树全表扫描，需要中序遍历全部的节点，而B+树直接遍历叶子节点的链表即可，效率更高。
- 更适合磁盘预读优化：磁盘通常按页（4KB）读取数据，连续数据读取效率更高。而B+树叶子节点存储连续数据，顺序访问时磁盘预读效率更高。

### （待补充）计算B+树的高度

### Hash

- Hash索引只能用于对等比较(=, in)，不支持范围查询(between, >, <, ...)
- 无法利用Hash索引完成排序操作
- 查询效率高，通常只需要查询一次即可

在MySQL中，支持hash索引的是Memory存储引擎。 而**InnoDB中具有自适应hash功能**，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的（不支持用户手动构建）。

## 索引分类

### 索引分类

| 分类     | 含义                                                 | 特点                         | 关键字   |
| -------- | ---------------------------------------------------- | ---------------------------- | -------- |
| 主键索引 | 针对表中主键创建的索引                               | 默认自动创建，**只能有一个** | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的值重复                     | 可以有多个                   | UNIQUE   |
| 常规索引 | 快速定位特定数据                                     | 可以有多个                   |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个                   | FULLTEXT |

### 聚焦索引与二级索引

根据索引的**存储形式**，可以分为以下两种

| 分类     | 含义                                                         | 特点                   |
| -------- | ------------------------------------------------------------ | ---------------------- |
| 聚集索引 | 将数据存储与索引**放在一起**，索引结构的**叶子节点**保存了行数据 | **必须有，且只有一个** |
| 二级索引 | 将数据和索引分开存储，索引结构的叶子节点关联的是**对应的主键**。 | 可以存在多个           |

必须存在的聚集索引选取规则：

- 如果**存在主键**，主键索引就是聚集索引。
- 如果**不存在主键**，将使用第一个唯一索引作为聚集索引
- 如果**既不存在主键，也不存在唯一索引**，则InnoDB会自动生成一个rowid作为隐藏的聚集索引

### 回表查询

**先到**二级索引中查找数据，找到主键值，然后**再到**聚集索引中根据主键值，获取数据的方式，称之为回表查询。

## 索引语法

### 创建索引

```sql
CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,...);
```

### 查看索引

```sql
SHOW INDEX FROM table_name;
```

### 删除索引

```sql
DROP INDEX index_name ON table_name;
```

## 索引使用

### 最左前缀法则

最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。**查询时，索引最左边的列必须存在，否则索引全部失效。而且中间不能跳过某一列，否则该列后面的字段索引将失效。**

注意：最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，**条件编写的先后顺序无关。**

### 范围查询

联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效。

当范围查询使用>= 或 <= 时，走联合索引了，并且全部列均使用了索引，**所以，在业务允许的情况下，尽可能地使用>=或<=这类的范围查询。**

### 索引失效情况

- 索引列运算：**不要在索引列上进行运算操作，索引将失效。**
- 字符串不加引号：**字符串类型字段使用时，不加引号，索引将失效。**
- 模糊查询：**如果仅仅是尾部模糊查询，索引不会失效。如果是头部模糊查询，索引将失效。**
- or连接条件：**用or分开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。**
- 数据分布影响：**如果MySQL评估使用索引比全表更慢，则不使用索引。**

### SQL提示

- `use index(index_name)`：建议MySQL使用哪一个索引完成此次查询**(仅仅是建议，MySQL内部还是会再次进行评估)**
- `ignore index(index_name)`：忽略指定的索引
- `force index(index_name)`：强制使用某索引

### 覆盖索引

覆盖索引是指查询使用了索引，并且需要返回的列，**在该索引中已经全部能够被找到。**

查询的数据在联合索引内时，直接返回二级索引上的数据，不需要再获取主键id后进行回表查询了，所以效率更高。

### 前缀索引

当字段类型为字符串(varchar, text, longtext)时，有时候需要索引很长的字符串，这会让索引变得很大，查询时需要频繁I/O，浪费大量资源，影响查询效率。此时可以只讲字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提升索引效率。

```sql
CREATE INDEX idx_xxxx on table_name(column(n));
```

如何确定前缀长度？

可以根据**索引的选择性**来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

### 单列索引与联合索引

- 单列索引：即一个索引只包含单个列
- 联合索引：即一个索引包含了多个列

**在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。**

## 索引设计原则

- 针对数据量较大，且查询比较频繁的表建立索引
- 针对经常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引
- 尽量选择区分度高的列座位索引，**尽量建立唯一索引**，区分度越高，使用索引的效率越高
- 如果是字符串类型的字段，可以考虑建立前缀索引
- **尽量使用联合索引**，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率
- 要**控制索引的数量**，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率
- 如果索引列不能存储NULL值，请在创建表时使用`NOT NULL`约束它。当优化器知道每列是否包含NULL值时，它能更好地确定哪个索引可以最有效地查询



# SQL性能分析

## SQL执行频率

查询当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：

```sql
SHOW GLOBAL STATUS LIKE 'Com_______'
```

通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是**以增删改为主**，我们可以考虑**不对其进行索引的优化**。 如果是**以查询为主**，那么就**要考虑对数据库的索引进行优化**了。

## 慢查询日志

慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位：秒，默认10秒)的所有SQL语句的日志。

MySQL的慢查询日志**默认没有开启**，需要在配置文件中打开。

## profile详情

`show profiles`能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。

```sql
-- 查看每一条SQL的耗时基本情况
show profiles;

-- 查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;

-- 查看指定query_id的SQL语句CPU的使用情况
show profile cpu for query query_id;
```

## explain

`EXPLAIN`命令或`DESC`获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。

```sql
-- 直接在select语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;
```

EXPLAIN执行计划中各个字段的含义：

| 字段         | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| id           | select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。 |
| select_type  | 表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等。 |
| type         | 表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all 。 |
| possible_key | 显示可能应用在这张表上的索引，一个或多个。                   |
| key          | 实际使用的索引，如果为NULL，则没有使用索引。                 |
| key_len      | 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。 |
| rows         | MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。 |
| filtered     | 表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。 |



# SQL优化

## 插入数据

如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面优化：

- 批量插入数据
  ```sql
  insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
  ```

- 手动控制事务
  ```sql
  start transaction;
  
  insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
  insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'Jerry');
  
  commit;
  ```

- 主键顺序插入，性能高于乱序插入

### 大批量插入数据

如果要一次性插入大批量数据（比如几百万条记录），使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。

## （待补充）主键优化



## order by优化

**MySQL的排序，有两种方式：**

- `Using filesort`：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作。**所有不是通过索引直接返回排序的结果的排序都叫FileSort排序。**
- `Using index`：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，效率更高。

对于以上两种方式，Using index性能更高，而Using filesort的性能低，我们在优化排序操作时，**要尽量优化为Using index**。

**order by优化原则：**

- 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则
- 尽量使用覆盖索引
- 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则
- 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小

## group by优化

在分组操作中，需要通过以下两点进行优化，以提升性能：

- 在分组操作时，可以通过索引来提高效率
- 分组操作时，索引的使用也是满足最左前缀法则的

## limit优化

一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过**覆盖索引加子查询形式进行优化。**

## count优化（待补充count(*)等问题）

- MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。

- InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。

如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数据库进行,但是如果是带条件的count又比较麻烦了)。

## update优化

InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁。故在update时需注意where的条件是否在索引内，避免使用表锁。



# 锁

锁是计算机协调多个进程或线程并发访问某一资源的机制。

MySQL中的锁，按照锁的粒度分，分为以下三类：

- 全局锁：锁定数据库中的所有表
- 表级锁：每次操作锁住整张表
- 行级锁：每次操作锁住对应的行数据

## 全局锁

全局锁就是对**整个数据库实例**加锁，加锁后整个实例就处于只读状态，后续的**DML的写语句，DDL语句，已经更新操作的事务提交语句**都将被阻塞。

其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。

加全局锁

```sql
flush tables with read lock;
```

释放锁

```sql
unlock tables;
```

### 全局锁的问题

数据库中加全局锁，是一个比较重的操作，存在以下问题：

- 如果**在主库上备份**，那么在备份期间都不能执行更新，业务基本停摆
- 如果**在从库上备份**，那么在备份期间从库不能执行主库同步过来的二进制日志(binlog)，会导致主从延迟

## 表级锁

表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。

对于表级锁，主要分为以下三类：

- 表锁
- 元数据锁
- 意向锁

### 表锁

对于表锁，分为两类：

- 表共享读锁(read lock)：读锁允许多个会话同时**读取**表中的数据，但会阻塞其他会话的**写入**操作。
  - 共享性：多个会话可以同时持有读锁
  - 阻塞写操作：其他会话可以读，但是不能写（要等待读锁释放）
  - 会话自身限制：持有读锁的会话不能执行写操作**（否则会报错）**

- 表独占写锁(write lock)：写锁是独占的，持有写锁的会话可以**读写**表，但会阻塞其他会话的**所有操作**（读和写）。
  - 排他性：同一时间只有一个会话能持有写锁
  - 完全阻塞：其他会话的读、写操作都会被阻塞，直到写锁释放
  - 会话自身权限：持有写锁的会话可以自由读写表


```sql
lock tables 表名... read / write;
unlock tables;
```

### 元数据锁

保护数据库对象（如表、视图等）的元数据（如表结构）的一种锁机制。它的核心目的是确保在并发操作中，元数据的一致性，防止因表结构变更（如`ALTER TABLE`）导致的数据不一致问题。

- 

  隐式加锁

  ：MDL不需要手动操作，MySQL自动在以下场景加锁：

  - 执行`SELECT`、`INSERT`、`UPDATE`、`DELETE`等DML操作时，会加**共享读锁（MDL读锁）**。
  - 执行`ALTER TABLE`、`DROP TABLE`、`RENAME TABLE`等DDL操作时，会加**排他写锁（MDL写锁）**。

- 锁的兼容性：

  | **当前持有的MDL锁** | **允许其他会话的MDL读锁** | **允许其他会话的MDL写锁** |
  | :-----------------: | :-----------------------: | :-----------------------: |
  |  MDL读锁（共享锁）  |             ✅             |     ❌（阻塞DDL操作）      |
  |  MDL写锁（排他锁）  |             ❌             |             ❌             |

### 意向锁

MySQL中的**意向锁（Intention Lock）**是InnoDB存储引擎实现的一种**表级锁**，用于支持多粒度锁（表锁和行锁共存）的高效管理。它的核心作用是**快速判断表级锁和行级锁的兼容性**，避免在加表锁时逐行检查行锁状态，从而提升并发性能。

InnoDB支持两种意向锁：

- **意向共享锁（Intention Shared Lock, IS）**
  表示事务**准备对表中的某些行加共享锁（行级读锁）​**。
  例如：`SELECT ... LOCK IN SHARE MODE` 语句会先加IS锁。
- **意向排他锁（Intention Exclusive Lock, IX）**
  表示事务**准备对表中的某些行加排他锁（行级写锁）​**。
  例如：`SELECT ... FOR UPDATE` 或 `UPDATE`、`DELETE` 语句会先加IX锁。

核心目的：

在表级锁和行级锁共存时，**快速判断表级锁是否兼容**。

- 当一个事务想加**表级锁**（如`LOCK TABLES ... WRITE`）时，只需检查表上是否存在**意向锁**，而无需遍历所有行级锁。
- 若表上存在意向锁（IS或IX），说明某些行已被锁定，表级锁可能无法直接加上（需等待）。

意向锁的兼容性：

| **当前锁类型** | **IS（意向共享锁）** | **IX（意向排他锁）** | **S（表级共享锁）** | **X（表级排他锁）** |
| :------------: | :------------------: | :------------------: | :-----------------: | :-----------------: |
|     **IS**     |          ✅           |          ✅           |          ✅          |          ❌          |
|     **IX**     |          ✅           |          ✅           |          ❌          |          ❌          |
|     **S**      |          ✅           |          ❌           |          ✅          |          ❌          |
|     **X**      |          ❌           |          ❌           |          ❌          |          ❌          |

- **意向锁之间兼容**：IS和IX可以共存（因为行级锁可能作用于不同行）。
- 意向锁与表级锁部分兼容：
  - IS与表级共享锁（S）兼容，但与表级排他锁（X）不兼容。
  - IX与所有表级锁（S/X）均不兼容。

## 行级锁

行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。

InnoDB的数据是基于索引组织的，行锁是**通过对索引上的索引项加锁**来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：

- **行锁(Record Lock)**：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。
- **间隙锁(Gap Lock)**：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。
- **临键锁(Next-Key Lock)**：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。

### 行锁

- **共享锁**：允许一个事物去读一行，阻止其他事务获取相同数据的排它锁
- **排他锁**：允许获取排它锁的事务更新数据，阻止其他事务获取相同数据集的共享锁和排它锁

| **当前锁类型** | **S（共享锁）** | X（排它锁） |
| :------------: | :-------------: | :---------: |
|  S（共享锁）   |        ✅        |      ❌      |
|  X（排它锁）   |        ❌        |      ❌      |

常见的SQL语句，在执行时，所加的行锁如下：

| SQL                           | 行锁类型   | 说明                   |
| ----------------------------- | ---------- | ---------------------- |
| INSERT ...                    | 排它锁     | 自动加锁               |
| UPDATE ...                    | 排它锁     | 自动加锁               |
| DELETE ...                    | 排它锁     | 自动加锁               |
| SELECT ..                     | 不加任何锁 |                        |
| SELECT ... LOCK IN SHARE MODE | 共享锁     | 需要手动在SELECT后面加 |
| SELECT ... FOR UPDATE         | 排它锁     |                        |

行锁的风险点：

- **死锁**
- **锁升级**：如果一个事务试图锁定的行数过多，InnoDB可能会将**行锁升级为表锁**，造成更多的并发冲突。
- **锁等待**：如果一个事务已经锁定了某一行，那么其他事务就必须等待。如果有大量事务在等待锁，就会造成性能瓶颈。
- **资源消耗**：行级锁需要更多的内存来存储锁信息，而且需要更多的CPU时间来请求锁和释放锁
- **难以调度和排查**
- **事务隔离级别**

### 间隙锁

间隙锁锁定的不是具体的行记录，而是**两个索引之间的间隙（或者说区间）**，这样可以防止新的记录插入到该间隙，确保数据的一致性和事务的隔离性。

间隙锁常常与记录锁一起使用，共同形成Next-Key锁，保护索引记录的范围查询与扫描操作。

以下是间隙锁的主要类型：

- **区间-区间间隙锁**：锁定两个索引键之间的间隙，或者是第一个索引键之前的间隙
- **区间-记录间隙锁**：锁定一个索引键和一个记录之间的间隙
- **记录-区间间隙锁**：锁定一个记录和一个索引键之间的间隙

间隙锁在MySQL数据库的InnoDB引擎中主要用于以下场景：

- **防止幻读**
- **范围查询**：在执行范围查询时，如果事务需要对查询结果进行更新或删除，那么间隙锁可以保证在事务执行期内，不会有新的行插入到查询范围中。

间隙锁的风险点：

- **性能影响**：间隙锁会阻止其他事务在已经锁定的范围内插入新的行，可能会影响到数据库的并发性能
- **死锁风险**：虽然间隙锁可以在某些情况下防止死锁，但在其他情况下，可能会增加死锁的风险。**比如：两个事务都想在同一间隙中插入新的行，就可能发生死锁。**
- **复杂性**：理解间隙锁及其对事务的影响可能需要相当深入的数据库知识，尤其是在处理并发问题和调优数据库性能时
- **锁定范围过大**：间隙锁锁定的是索引之间的间隙，这可能会比实际需要锁定的行更多。

### 临键锁

每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段**左开右闭区间**的数据。需要强调的一点是，InnoDB中行级锁是基于索引实现的，临键锁**只与非唯一索引列**有关，在**唯一索引列（包括主键列）上不存在临键锁**。



## 乐观锁与悲观锁（待补充）

# InnoDB引擎

## InnoDB逻辑存储结构（待补充）

## InnoDB架构

<img src="MySQL强化笔记.assets/截屏2025-03-01 21.37.11.png" alt="截屏2025-03-01 21.37.11" style="zoom: 33%;" />

### 内存结构

- `Buffer Pool` 缓冲池

  InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了**尽可能弥补这两者之间的I/O效率的差值**，就需要把经常使用的数据加载到**缓冲池**中，避免每次访问都进行磁盘I/O。

  在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。

  缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，**先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。**

  缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：

  - free page：空闲page，未被使用
  - clean page：被使用page，数据没有被修改过
  - dirty page：脏页，被使用page，数据被修改过，其中**数据与磁盘数据产生了不一致**

- `Change Buffer` 更改缓冲区
  **针对于非唯一二级索引页**，在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区Change Buffer

  中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。

- `Adaptive Hash Index` 自适应哈希索引
  用于优化对Buffer Pool数据的查询

- `Log Buffer` 日志缓冲区
  用来保存要写入到磁盘中的log日志数据(redo log, undo log)，默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的书屋，增加日志缓冲区的大小可以节省磁盘I/O。

### 磁盘结构

- `System Tablespace`

  用于存储数据库的全局元数据、关键数据结构以及部分系统级数据。

- `File-Per-Table Tablespaces`

  如果开启了`innodb_file_per_table`开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。

- `General Tablespaces`

  通用表空间（待补充）

- `Undo Tablespaces` 撤销表空间

- `Temporary Tablespaces` 全局临时表空间，存储用户创建的临时表等数据

- `Doublewrite Buffer Files` 双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。

- `Redo Log`

  重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。

### 后台线程

- `Master Thread`：核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收。
- `I/O Thread`
- `Purge Thread`：主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用此线程来回收。
- `Page Cleaner Thread`：协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。

## 事务原理

**事务**是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，这些操作要么同时成功，要么同时失败。

特性：

- A：Atomicity，原子性。事务是不可分割的最小操作单元，要么全部成功，要么全部失败
- C：Consistency，一致性。事务完成时，必须使所有的数据都保持一致状态
- I：Isolation，隔离性。数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行
- D：Durability，持久性。事务一旦提交或回滚，它对数据库中的数据的改变就是永久的

### redo log

重做日志，记录的是事务提交时数据页的物理修改，是用来**实现事务的持久性。**

该日志文件由两部分组成：重做日志缓冲(redo log buffer)以及重做日志文件(redo log file)，前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。

**为什么每一次提交事务，要刷新redo log到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢？**

因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL(Write-Ahead Logging)。

### undo log

回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制) 。

undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undolog中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。

## MVCC(Multi-Version Concurrency Control)



