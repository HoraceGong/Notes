---
title: MySQL强化笔记
date: 2024-05-26 20:08:14
tags: [MySQL, note]
---

包括MySQL基础、MySQL调优等。

<!-- more -->

# 存储引擎

## MySQL四层架构

1. 连接层

   最上层是一些**客户端和链接服务**，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为**通过认证安全接入的客户端提供线程**。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。

2. 服务层

   第二层架构主要完成大多数的**核心服务功能**，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。

3. 引擎层

   存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取。**数据库中的索引是在存储引擎层实现的**。

4. 存储层

   数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。

## 什么是存储引擎

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。**存储引擎是基于表的**，而不是基于库的，所以存储引擎也可被称为表类型。我们可以在创建表的时候，来指定选择的存储引擎，如果没有指定将自动选择默认的存储引擎。



三种常见的存储引擎：

- InnoDB：兼顾高可靠性和高性能的通用存储引擎，在MySQL 5.5之后，是**默认的存储引擎**。
- MyISAM：MySQL早起的默认存储引擎
- Memory：表数据临时存储在内存中，由于受到硬件问题或断电问题等的影响，只能将这些表作为临时表或者缓存使用



### InnoDB

- DML操作遵循ACID模型，支持事务
- 行级锁，提高并发访问性能
- 支持外键约束，保证数据的完整性和正确性

文件：

xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和**索引**。文件是**基于二进制的**。MySQL提供指令`ibd2sdi`，可以通过该指令从ibd文件中提取sdi信息，而sdi数据字典信息中就包含该表的表结构。

### MyISAM

- 不支持事务，不支持外键
- 支持表锁，不支持行锁
- 访问速度快

文件：

- xxx.sdi：存储表结构信息

- xxx.MYD: 存储数据

- xxx.MYI: 存储索引

### Memory

- 内存存放
- hash索引（默认）

## 存储引擎如何选择

- InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用**对事务的完整性有比较高的要求**，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还**包含很多的更新、删除操作**，那么InnoDB存储引擎是比较合适的选择。
- MyISAM ：如果应用是**以读操作和插入操作为主**，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。
- MEMORY：将所有数据保存在内存中，**访问速度快**，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。

## （待补充）InnoDB的逻辑存储结构



# 索引

索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

## 索引结构

| 索引结构              | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| B+树索引              | 最常见的索引类型，大部分引擎都支持B+树索引                   |
| Hash索引              | 底层数据结构是使用**哈希表**实现的，**只有精确匹配索引列的查询才有效**，不支持范围查询 |
| R-tree（空间索引）    | MyISAM的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
| Full-text（全文索引） | 是一种通过建立倒排索引，快速匹配文档的方式                   |

### 索引结构为什么会选择B+树

B+树与B树相比，有以下三点区别：

- 所有数据都会出现在叶子结点
- 叶子结点形成一个单向链表
- 非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的

MySQL在原B+树的基础上，增加了一个指向相邻叶子结点的链表指针，就形成了带有顺序指针的B+树，提高区间访问的性能，便于排序。

**选择B+树的原因：**

- 更适合范围查询：若使用B树，因为数据存储在不同层的节点上，范围查询时需要跨多层回溯。而B+树所有数据都仅在叶子结点上，且叶子结点通过双向链表连接，范围查询只需要遍历链表即可。
- 更高的存储利用率：B树每个结点都要存储数据，导致单个节点可以容纳的键数量较小。而B+树仅存储键，单个节点能容纳更多键，树的高度更低，磁盘IO次数也就更少。
- 更稳定的查询性能：B+树所有数据均存储在叶节点上，每次查询必须走到叶子结点，路径长度一致，性能稳定。
- 更高效的全表扫描：B树全表扫描，需要中序遍历全部的节点，而B+树直接遍历叶子节点的链表即可，效率更高。
- 更适合磁盘预读优化：磁盘通常按页（4KB）读取数据，连续数据读取效率更高。而B+树叶子节点存储连续数据，顺序访问时磁盘预读效率更高。

### （待补充）计算B+树的高度

### Hash

- Hash索引只能用于对等比较(=, in)，不支持范围查询(between, >, <, ...)
- 无法利用Hash索引完成排序操作
- 查询效率高，通常只需要查询一次即可

在MySQL中，支持hash索引的是Memory存储引擎。 而**InnoDB中具有自适应hash功能**，hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的（不支持用户手动构建）。

## 索引分类

### 索引分类

| 分类     | 含义                                                 | 特点                         | 关键字   |
| -------- | ---------------------------------------------------- | ---------------------------- | -------- |
| 主键索引 | 针对表中主键创建的索引                               | 默认自动创建，**只能有一个** | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的值重复                     | 可以有多个                   | UNIQUE   |
| 常规索引 | 快速定位特定数据                                     | 可以有多个                   |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个                   | FULLTEXT |

### 聚焦索引与二级索引

根据索引的**存储形式**，可以分为以下两种

| 分类     | 含义                                                         | 特点                   |
| -------- | ------------------------------------------------------------ | ---------------------- |
| 聚集索引 | 将数据存储与索引**放在一起**，索引结构的**叶子节点**保存了行数据 | **必须有，且只有一个** |
| 二级索引 | 将数据和索引分开存储，索引结构的叶子节点关联的是**对应的主键**。 | 可以存在多个           |

必须存在的聚集索引选取规则：

- 如果**存在主键**，主键索引就是聚集索引。
- 如果**不存在主键**，将使用第一个唯一索引作为聚集索引
- 如果**既不存在主键，也不存在唯一索引**，则InnoDB会自动生成一个rowid作为隐藏的聚集索引

### 回表查询

**先到**二级索引中查找数据，找到主键值，然后**再到**聚集索引中根据主键值，获取数据的方式，称之为回表查询。

## 索引语法

### 创建索引

```sql
CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,...);
```

### 查看索引

```sql
SHOW INDEX FROM table_name;
```

### 删除索引

```sql
DROP INDEX index_name ON table_name;
```

## 索引使用

### 最左前缀法则

最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。**查询时，索引最左边的列必须存在，否则索引全部失效。而且中间不能跳过某一列，否则该列后面的字段索引将失效。**

注意：最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，**条件编写的先后顺序无关。**

### 范围查询

联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效。

当范围查询使用>= 或 <= 时，走联合索引了，并且全部列均使用了索引，**所以，在业务允许的情况下，尽可能地使用>=或<=这类的范围查询。**

### 索引失效情况

- 索引列运算：**不要在索引列上进行运算操作，索引将失效。**
- 字符串不加引号：**字符串类型字段使用时，不加引号，索引将失效。**
- 模糊查询：**如果仅仅是尾部模糊查询，索引不会失效。如果是头部模糊查询，索引将失效。**
- or连接条件：**用or分开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。**
- 数据分布影响：**如果MySQL评估使用索引比全表更慢，则不使用索引。**

### SQL提示

- `use index(index_name)`：建议MySQL使用哪一个索引完成此次查询**(仅仅是建议，MySQL内部还是会再次进行评估)**
- `ignore index(index_name)`：忽略指定的索引
- `force index(index_name)`：强制使用某索引

### 覆盖索引

覆盖索引是指查询使用了索引，并且需要返回的列，**在该索引中已经全部能够被找到。**

查询的数据在联合索引内时，直接返回二级索引上的数据，不需要再获取主键id后进行回表查询了，所以效率更高。

### 前缀索引

当字段类型为字符串(varchar, text, longtext)时，有时候需要索引很长的字符串，这会让索引变得很大，查询时需要频繁I/O，浪费大量资源，影响查询效率。此时可以只讲字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提升索引效率。

```sql
CREATE INDEX idx_xxxx on table_name(column(n));
```

如何确定前缀长度？

可以根据**索引的选择性**来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

### 单列索引与联合索引

- 单列索引：即一个索引只包含单个列
- 联合索引：即一个索引包含了多个列

**在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。**

## 索引设计原则

- 针对数据量较大，且查询比较频繁的表建立索引
- 针对经常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引
- 尽量选择区分度高的列座位索引，**尽量建立唯一索引**，区分度越高，使用索引的效率越高
- 如果是字符串类型的字段，可以考虑建立前缀索引
- **尽量使用联合索引**，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率
- 要**控制索引的数量**，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率
- 如果索引列不能存储NULL值，请在创建表时使用`NOT NULL`约束它。当优化器知道每列是否包含NULL值时，它能更好地确定哪个索引可以最有效地查询



# SQL性能分析

## SQL执行频率

查询当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：

```sql
SHOW GLOBAL STATUS LIKE 'Com_______'
```

通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是**以增删改为主**，我们可以考虑**不对其进行索引的优化**。 如果是**以查询为主**，那么就**要考虑对数据库的索引进行优化**了。

## 慢查询日志

慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位：秒，默认10秒)的所有SQL语句的日志。

MySQL的慢查询日志**默认没有开启**，需要在配置文件中打开。

## profile详情

`show profiles`能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。

```sql
-- 查看每一条SQL的耗时基本情况
show profiles;

-- 查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;

-- 查看指定query_id的SQL语句CPU的使用情况
show profile cpu for query query_id;
```

## explain

`EXPLAIN`命令或`DESC`获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。

```sql
-- 直接在select语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;
```

EXPLAIN执行计划中各个字段的含义：

| 字段         | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| id           | select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。 |
| select_type  | 表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等。 |
| type         | 表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all 。 |
| possible_key | 显示可能应用在这张表上的索引，一个或多个。                   |
| key          | 实际使用的索引，如果为NULL，则没有使用索引。                 |
| key_len      | 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。 |
| rows         | MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。 |
| filtered     | 表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。 |



# SQL优化

## 插入数据

如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面优化：

- 批量插入数据
  ```sql
  insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
  ```

- 手动控制事务
  ```sql
  start transaction;
  
  insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
  insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'Jerry');
  
  commit;
  ```

- 主键顺序插入，性能高于乱序插入

### 大批量插入数据

如果要一次性插入大批量数据（比如几百万条记录），使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。

## （待补充）主键优化



## order by优化

**MySQL的排序，有两种方式：**

- `Using filesort`：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作。**所有不是通过索引直接返回排序的结果的排序都叫FileSort排序。**
- `Using index`：通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，效率更高。

对于以上两种方式，Using index性能更高，而Using filesort的性能低，我们在优化排序操作时，**要尽量优化为Using index**。

**order by优化原则：**

- 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则
- 尽量使用覆盖索引
- 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则
- 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小

## group by优化

在分组操作中，需要通过以下两点进行优化，以提升性能：

- 在分组操作时，可以通过索引来提高效率
- 分组操作时，索引的使用也是满足最左前缀法则的

## limit优化

一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过**覆盖索引加子查询形式进行优化。**

## count优化（待补充count(*)等问题）

- MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。

- InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。

如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数据库进行,但是如果是带条件的count又比较麻烦了)。

## update优化

InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁。故在update时需注意where的条件是否在索引内，避免使用表锁。



# 锁

锁是计算机协调多个进程或线程并发访问某一资源的机制。

MySQL中的锁，按照锁的粒度分，分为以下三类：

- 全局锁：锁定数据库中的所有表
- 表级锁：每次操作锁住整张表
- 行级锁：每次操作锁住对应的行数据

## 全局锁

全局锁就是对**整个数据库实例**加锁，加锁后整个实例就处于只读状态，后续的**DML的写语句，DDL语句，已经更新操作的事务提交语句**都将被阻塞。

其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。

加全局锁

```sql
flush tables with read lock;
```

释放锁

```sql
unlock tables;
```

### 全局锁的问题

数据库中加全局锁，是一个比较重的操作，存在以下问题：

- 如果**在主库上备份**，那么在备份期间都不能执行更新，业务基本停摆
- 如果**在从库上备份**，那么在备份期间从库不能执行主库同步过来的二进制日志(binlog)，会导致主从延迟

## 表级锁

表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。

对于表级锁，主要分为以下三类：

- 表锁
- 元数据锁
- 意向锁

### 表锁

对于表锁，分为两类：

- 表共享读锁(read lock)
- 表独占写锁(write lock)

```sql
lock tables 表名... read / write;
unlock tables;
```

