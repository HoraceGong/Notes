来源：

https://blog.csdn.net/yy339452689/article/details/110956119

https://zhuanlan.zhihu.com/p/596780556

# 为什么引入Stream

在工作中集合对于很多编程任务来说都是非常基本的，但是关于集合上的很多处理方式都是类似于数据库一样的操作，比如匹配某个值，筛选部分元素，对数据进行分组等等，java8之前使用集合处理这些问题就比较麻烦，而且如果集合数据量比较大，为了提高性能，你还需要额外写代码进行并发处理，那就变的更加复杂了。

而引入Stream就是为了让关于集合的操作更加简单，Java 8 中的 Stream 是对集合功能的增强，它允许你**以声明性方式处理数据集合**。就现在来说，你可以把它们看成遍历数据集的高级迭代器。此外，Stream还可以透明地并行处理，你无需写任何多线程代码，极大的提高编程效率和程序可读性。



# 简介

## Stream定义与基本特征

那么Stream是什么？简短的定义就是“源中支持聚合操作的一系列元素”。让我们分解一下：

- **元素序列：**流为特定元素类型的序列值集提供接口。但是，流实际上并不存储元素。它们是按需计算的。
- **源：**流从提供数据的源（例如集合，数组或I / O资源）进行消耗。
- **聚合操作：**流支持像SQL一样功能的编程语言操作和常用的操作，如filter，map，reduce，find，match，sorted等。

此外，流操作具有两个基本特征：

- **流水线：**许多流操作本身都会返回一个流。这允许将操作链接在一起以形成更大的管道。这使某些优化，如*懒惰*和*短路*，这是我们后来探索。
- **内部迭代：**与显式*迭代的*集合（*外部迭代*）相反，流操作为您在后台进行迭代。

## Stream与集合差异

有了基本概念后，我们再来了解下Stream集合的差异，既然Stream是对集合的增强，那两者之间具体有什么区别？可以参考以下官方文档中给出的区别：

**1 Sream没有存储空间。**流不是存储元素的数据结构。相反，它通过一系列计算操作从数据结构，数组，生成器功能或I / O通道等源中传递元素。

**2 Sream本质上是功能性的。**对流的操作会产生结果，但不会修改其源。例如，对Stream从集合中获取的Stream进行过滤会产生一个不包含过滤后元素的新元素，而不是从源集合中删除元素。

**3 懒惰查找。**许多流操作（例如过滤，映射或重复删除）可以延迟实施，从而暴露出优化的机会。例如，“String使用三个连续的元音查找第一个”不需要检查所有输入字符串。流操作分为中间（产生Stream）操作和最终（产生值或副作用）操作。中间操作总是很懒。

**4 可以无界。**尽管集合的大小是有限的，但流不是必需的。诸如limit(n)或findFirst() 的短路操作可以允许对无限流的计算在有限时间内完成。

**5 消耗品。**在流的生存期内，流的元素只能访问一次。与 Iterator一样，必须生成新的流以重新访问源中的相同元素。

# Stream构成

## Stream分类

Stream主要分为串行流和并行流，可分别通过`stream()`和`parallelStream()`，其中parallelStream()底层使用fork/join框架实现，不需要显式地写并行代码就可以直接对流进行并行操作。

## Stream操作类型

流操作分为*中间*操作和*终端*操作，并合并以形成*流管道*。流管道由源（例如Collection，数组，生成器函数或I/O通道）组成；随后是零个或多个中间操作，例如Stream.filter或Stream.map；以及诸如Stream.forEach或Stream.reduce的终端操作。

### 中间操作

中间操作返回一个新的流。他们总是*懒惰*; 执行诸如这样的中间操作filter(),实际上并不执行任何过滤，而是创建一个新的流，该新流在遍历时将包含与给定谓词匹配的初始流的元素。在执行管道的终端操作之前，不会开始遍历管道源。中间操作又分为无状态操作和有状态操作。

- **无状态操作**：指元素的处理不受之前元素的影响。

- **有状态操作**：指该操作只有拿到所有元素之后才会继续下去。

### 终端操作

终端操作（例如Stream.forEach或IntStream.sum）可能会遍历流以产生结果或作用。执行终端操作后，流管道被视为已消耗，无法再使用；如果需要再次遍历同一数据源，则必须返回到数据源以获取新的流。终端操作可分为短路操作(如findFirst，allMatch)和非短路操作(如forEach，reduce)。

- **短路操作**：获得到预期结果就会终止。比如`anyMatch`, `findFirst`等。
- **非短路操作**：处理完所有的数据才会中止，比如`collect`, `count`等。

# Stream API的使用

当我们使用一个流的时候，通常包括三个基本步骤：

获取一个数据源 -> 数据转换 -> 执行操作获取想要的结果。**每次转换原有Stream对象不改变，返回一个新的Stream对象**，这就允许对其操作可以像链条一样排列，变成一个管道。
